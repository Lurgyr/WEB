<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Задание 1</title>
<LINK rel=stylesheet type="text/css" href="style.css">
<LINK rel=stylesheet type="text/css" href="normalize.css">
</head>
<body>
<p style="text-align:left"><img src="c1.png" height="200" width="200"></p>
<p>
  <blockquote><small>«При помощи C вы легко можете выстрелить себе в ногу. При помощи C++ это сделать сложнее, но если это произойдёт, вам оторвёт всю ногу целиком.» </small></blockquote>
  <p><blockquote><small>Bjarne Stroustrup. Создатель C++</small></blockquote>
</p>
<div>
<h2>Содержание</h2>
<ol>
    <li><a href="#history">История создания</a></li>
    <li><a href="#view">Краткий обзор языка</a></li>
    <li><a href="#ex">Примеры кода</a></li>
</ol>
</div>
<hr>
<h2 id = "history"; >История создания</h2>
<p>Язык возник в начале 1980-х годов, когда сотрудник фирмы Bell Labs <b>Бьёрн Страуструп</b> придумал ряд усовершенствований к языку C под собственные нужды. Когда в конце 1970-х годов Страуструп начал работать в Bell Labs над задачами теории очередей (в приложении к моделированию телефонных вызовов), он обнаружил, что попытки применения существовавших в то время языков моделирования оказались неэффективными, а применение высокоэффективных машинных языков слишком сложно из-за их ограниченной выразительности. Так, язык Симула имеет такие возможности, которые были бы очень полезны для разработки большого программного обеспечения, но работает слишком медленно, а язык BCPL достаточно быстр, но слишком близок к языкам низкого уровня и не подходит для разработки большого программного обеспечения.
<p>
Вспомнив опыт своей диссертации, Страуструп решил дополнить язык C (преемник BCPL) возможностями, имевшимися в языке Симула. Язык C, будучи базовым языком системы UNIX, на которой работали компьютеры Bell, является быстрым, многофункциональным и переносимым. Страуструп добавил к нему возможность работы с классами и объектами. В результате практические задачи моделирования оказались доступными для решения как с точки зрения времени разработки (благодаря использованию Симула-подобных классов), так и с точки зрения времени вычислений (благодаря быстродействию C). В первую очередь в C были добавлены классы (с инкапсуляцией), наследование классов, строгая проверка типов, inline-функции и аргументы по умолчанию. Ранние версии языка, первоначально именовавшегося «C with classes» («Си с классами»), стали доступны с 1980 года.
<p>
Разрабатывая C с классами, Страуструп написал программу <b>cfront</b> — транслятор, перерабатывающий исходный код C с классами в исходный код простого C. Это позволило работать над новым языком и использовать его на практике, применяя уже имевшуюся в UNIX инфраструктуру для разработки на C. Новый язык, неожиданно для автора, приобрёл большую популярность среди коллег и вскоре Страуструп уже не мог лично поддерживать его, отвечая на тысячи вопросов.
<p>
К 1983 году в язык были добавлены новые возможности, такие как виртуальные функции, перегрузка функций и операторов, ссылки, константы, пользовательский контроль над управлением свободной памятью, улучшенная проверка типов и новый стиль комментариев (//). Получившийся язык уже перестал быть просто дополненной версией классического C и был переименован из C с классами в «C++». Его первый коммерческий выпуск состоялся в октябре 1985 года.
<p>
<table>
<tr>
<td>
<i>Имя языка, полученное в итоге, происходит от оператора унарного постфиксного инкремента C ++ (увеличение значения переменной на единицу). Имя C+ не было использовано потому, что является синтаксической ошибкой в C и, кроме того, это имя было занято другим языком. Язык также не был назван D, поскольку «является расширением C и не пытается устранять проблемы путём удаления элементов C»
</i>
</tr>
</td>
</table>
<p>До начала официальной стандартизации язык развивался в основном силами Страуструпа в ответ на запросы программистского сообщества. Функцию стандартных описаний языка выполняли написанные Страуструпом печатные работы по C++ (описание языка, справочное руководство и так далее). Лишь в 1998 году был ратифицирован международный стандарт языка C++: ISO/IEC 14882:1998 «Standard for the C++ Programming Language»; после принятия технических исправлений к стандарту в 2003 году — следующая версия этого стандарта — ISO/IEC 14882:2003.
Стандартная библиотека C++ также развивалась вместе с ним. Первым добавлением к стандартной библиотеке C++ стали потоки ввода-вывода, обеспечивающие средства для замены традиционных функций C printf и scanf. Позднее самым значительным развитием стандартной библиотеки стало включение в неё Стандартной библиотеки шаблонов.
<p>
<ul class = 'mark'>
<li>Официальная стандартизация языка началась в 1998 году, когда был опубликован стандарт языка ISO/IEC 14882:1998 (известный как C++98)[9], разработанный комитетом по стандартизации C++ (ISO/IEC JTC1/SC22/WG21 working group). Стандарт C++ не описывал способов именования объектов, некоторых деталей обработки исключений и других возможностей, связанных с деталями реализации, что делает несовместимым объектный код, созданный различными компиляторами. Однако для этого третьими лицами создано множество стандартов для конкретных архитектур и операционных систем.</li>
<li>В 2003 году опубликован стандарт C++ ISO/IEC 14882:2003, где исправлены выявленные ошибки и недочёты предыдущей версии стандарта. В 2005 году опубликован отчёт Library Technical Report 1 (кратко называемый TR1). Не являясь официально частью стандарта, отчёт описывает расширения стандартной библиотеки, которые, по мнению авторов, должны были быть включены в следующую версию стандарта. Степень поддержки TR1 улучшается почти во всех поддерживаемых компиляторах языка C++.</li>
<li>С 2009 года велась работа по обновлению предыдущего стандарта. Предварительная версия называлась C++09, в следующем году её переименовали в C++0x. Стандарт был опубликован в 2011 году под названием C++11. В него включены дополнения в ядре языка и расширение стандартной библиотеки, в том числе большая часть TR1.</li>
<li>Следующая версия стандарта, C++14, вышла в августе 2014 года. Она содержит в основном уточнения и исправления ошибок предыдущей версии.</li>
<li>Стандарт C++17, опубликованный в декабре 2017 года, включил в стандартную библиотеку параллельные версии стандартных алгоритмов и удалил некоторые устаревшие и крайне редко используемые элементы.</li>
<li>Последняя стабильная на текущий момент действующая версия стандарта — C++20. Помимо прочего, он содержит принципиальное новшество — поддержку модулей.</li>
<li>Стандарт C++23 на данный момент активно обсуждается комитетом ISO.</li>
</ul>
</p>

<h2 id = "view">Краткий обзор языка</h2>
<p>Первое время язык развивался вне формальных рамок, 
спонтанно, по мере встававших перед ним задач. Развитию 
языка сопутствовало развитие кросс-компилятора cfront. 
Новшества в языке отражались в изменении номера версии 
кросс-компилятора. Эти номера версий кросс-компилятора 
распространялись и на сам язык, но применительно к настоящему 
времени речь о версиях языка C++ не ведут. Лишь в 1998 году язык 
стал стандартизированным.
</p>
<ul>
<li>C++ поддерживает как комментарии в стиле C (/* комментарий */), 
так и однострочные (// вся оставшаяся часть строки является
 комментарием), где // обозначает начало комментария, а ближайший
  последующий символ новой строки, который не предварён символом \ 
  (либо эквивалентным ему обозначением ??/), считается окончанием 
  комментария. Плюс этого комментария в том, что его не обязательно 
  заканчивать, то есть обозначать окончание комментария.</li>
  <li>Спецификатор inline для функций. Функция, определённая внутри тела 
класса, является inline по умолчанию. Данный спецификатор является
 подсказкой компилятору и может встроить тело функции в код вместо 
 её непосредственного вызова.</li>
 <li>Квалификаторы const и volatile. В отличие от С, где const обозначает 
только доступ на чтение, в C++ переменная с квалификатором const должна 
быть инициализирована. volatile используется в описании переменных и 
информирует компилятор, что значение данной переменной может быть изменено
 способом, который компилятор не в состоянии отследить. Для переменных, 
 объявленных volatile, компилятор не должен применять средства оптимизации,
  изменяющие положение переменной в памяти (например, помещающие её в 
  регистр) или полагающиеся на неизменность значения переменной в промежутке
   между двумя присваиваниями ей значения.</li>
   <li>Пространства имён (namespace).</li>
</ul>
</p>
<p>
  В C++ доступны следующие встроенные типы:
  <ul>
  <li>символьные: char, wchar_t (char16_t и char32_t, в стандарте C++11);</li>
    <li>целочисленные знаковые: signed char, short int, int, long int (и long long, в стандарте C++11);</li>
    <li>целочисленные беззнаковые: unsigned char, unsigned short int, unsigned int, unsigned long int (и unsigned long long, в стандарте C++11);</li>
    <li>с плавающей точкой: float, double, long double;</li>
    <li>логический: bool, имеющий значения либо true, либо false.</li>
  </ul>
</p>
<p>
Рейтинг языков программирования
</p>
<table class="t1">
  <caption>Рейтинг языков программирования  .</caption>
  <thead>
    <tr>
      <th>Место</th>
      <th>Язык</th>
      
    
    </tr>
  </thead>
  <tbody>
    <tr><th>1</th><td>Python</td></tr>
    <tr><th>2</th><td>C</td></tr>
    <tr><th>3</th><td>Java</td></tr>
    <tr><th>4</th><td>C++</td></tr>
    <tr><th>5</th><td>C#</td></tr>
    <tr><th>6</th><td>Visual Basic</td></tr>
    <tr><th>7</th><td>JavaScript</td></tr>
    <tr><th>8</th><td>PHP</td></tr>
    <tr><th>9</th><td>SQL</td></tr>
    <tr><th>10</th><td>Assembly language</td></tr>
  </tbody>
</table>
<p>
  </p>
<h2 id = "ex">Примеры кода</h2>
<div class="block1">
  <p>Это пример программы Hello, world!, которая выводит сообщение в консоль, используя стандартную библиотеку, и завершается.  </p>
  <p><span class="f">#include</span> <span class="m">&ltiostream&gt </p>
  <p>
  <p> <span class="m">// Импортируем все объявления в пространстве имён "std" в глобальное пространство имён.</span>
  <p><span class="g">using namespace</span> <span class="b">std;</span>
  <p>
  <p><span class="r">int</span> <span class="b">main()</span>
  <p> {
  <p style="text-indent: 25px">   cout << <span class="r">"Hello, world!"</span> << endl;
  <p style="text-indent: 25px">   <span class="g">return 0;</span>
  <p> }

</div>

<div class="block3">
  Современный C++ позволяет решать простым способом и более сложные задачи. Этот пример демонстрирует, 
  кроме всего прочего, использование контейнеров стандартной библиотеки шаблонов.
  <p><span class="f">#include</span><span class="m"> &ltiostream&gt // для использования std::cout</span>
  <p><span class="f">#include</span><span class="m"> &ltvector&gt // содержит динамический массив</span>
  <p><span class="f">#include</span><span class="m"> &ltmap&gt // содержит тип данных словарь</span>
  <p><span class="f">#include</span><span class="m"> &ltstring&gt</p></span>
  <p>  
  <p><span class="g">using namespace</span> <span class="b">std;</span>
  <p>  
  <p><span class="r">int</span> <span class="b">main()</span>
  <p> { 
  <p style="text-indent: 25px"><span class="m"> // Объявляем ассоциативный контейнер со строковыми ключами и данными в виде векторов строк.</span>
  <p style="text-indent: 25px">map<string, vector<string> > items;
  <p>
  <p style="text-indent: 25px">     <span class="m"> // Добавим в этот ассоциативный контейнер пару человек и дадим им несколько предметов.</span>
  <p style="text-indent: 25px">      items[<span class="r">"Anya"</span>].push_back(<span class="r">"scarf"</span>);
  <p style="text-indent: 25px">      items[<span class="r">"Dmitry"</span>].push_back(<span class="r">"tickets"</span>);
  <p style="text-indent: 25px">      items[<span class="r">"Anya"</span>].push_back(<span class="r">"puppy"</span>);
  <p style="text-indent: 25px">  
  <p style="text-indent: 25px">      <span class="m">// Переберём все объекты в контейнере</span>
  <p style="text-indent: 25px">      <span class="g">for</span>(<span class="g">const auto</span>& person : items) {
  <p style="text-indent: 45px">        <span class="m">  // person - это пара двух объектов: person.first - это его имя,</span>
  <p style="text-indent: 45px">        <span class="m">  // person.second - это список его предметов (вектор строк)</span>
  <p style="text-indent: 45px">          cout << person.first << <span class="r">" is carrying "</span> << person.second.size() << <span class="r">" items" </span><< endl;
  <p style="text-indent: 25px">      }
  <p>  }
  </p>
</div>
</p>
<p>
<p>Теги</p>
<ol style="column-count:2; text-align:justify;">
    <li>&lthtml&gt
    <li>&lttitle&gt
    <li>&lthead&gt
    <li>&ltbody&gt
    <li>&ltlink&gt
    <li>&ltaddress&gt
    <li> &ltdiv&gt
    <li>&ltp&gt
    <li>&lth1&gt
    <li>&lth2&gt
    <li>&ltdiv&gt
    <li>&ltol&gt
    <li>&ltli&gt
    <li>&lttable&gt  
    <li>&lttr&gt
    <li>&lttd&gt
    <li>&ltul&gt
    <li>&ltcaption&gt
    <li>&ltthead&gt
    <li>&lttbody&gt
    <li>&ltspan&gt
    <li>&ltimg&gt
    <li>&lta&gt
    <li>&ltth&gt
    <li>&lthr&gt
    <li>&lti&gt
    <li>&ltins&gt
    <li> &ltdoctype&gt
    <li>&ltb&gt
    <li>&ltblockquote&gt
    <li>&ltsmall&gt
    <li>&ltmeta&gt
  </ol>
</p>
<p>
  <p>CSS свойства</p>
  <ol style= " align= center; column-count:2; text-align:justify;">
    <li>font-size
    <li>text-aligh
    <li>font-family
    <li>text-indent
    <li>padding
    <li>padding-left
    <li>padding-right
    <li>padding-bottom
    <li>padding-top
    <li>list-style-image
    <li>color
    <li>background
    <li>border
    <li>width
    <li>height
    <li>float
    <li>overflow
    <li>margin
    <li>border-collapse
    <li>text-transform
    <li>border-right
    <li>border-bottom
    <li>margin-left
    <li>font-stretch
    <li>border-bottom-left-radius
    <li>border-bottom-right-radius
    <li>border-top-left-radius
    <li>border-top-right-radius
    <li>border-radius
    <li>outline-color
    <li>outline-offset
    <li>outline-style
    <li>outline-width
    <li>opacity
    <li>text-shadow
    <li>column-count
    <li>text-decoration
    <li>text-decoration-color
    <li>text-decoration-style
    <li>margin-top
  </ol>
</p>
</body>
</html>